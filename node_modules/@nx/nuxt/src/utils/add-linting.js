"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addLinting = addLinting;
const eslint_1 = require("@nx/eslint");
const path_1 = require("nx/src/utils/path");
const devkit_1 = require("@nx/devkit");
const eslint_file_1 = require("@nx/eslint/src/generators/utils/eslint-file");
const versions_1 = require("./versions");
const flat_config_1 = require("@nx/eslint/src/utils/flat-config");
// TODO(colum): Look into the recommended set up using `withNuxt` inside eslint.config.mjs. https://eslint.nuxt.com/packages/config
async function addLinting(host, options) {
    const tasks = [];
    if (options.linter === 'eslint') {
        const lintTask = await (0, eslint_1.lintProjectGenerator)(host, {
            linter: options.linter,
            project: options.projectName,
            tsConfigPaths: [(0, path_1.joinPathFragments)(options.projectRoot, 'tsconfig.json')],
            unitTestRunner: options.unitTestRunner,
            skipFormat: true,
            rootProject: options.rootProject,
            addPlugin: true,
        });
        tasks.push(lintTask);
        if ((0, eslint_file_1.isEslintConfigSupported)(host, options.projectRoot)) {
            editEslintConfigFiles(host, options.projectRoot);
            const addExtendsTask = (0, eslint_file_1.addExtendsToLintConfig)(host, options.projectRoot, ['@nuxt/eslint-config'], true);
            tasks.push(addExtendsTask);
            if ((0, flat_config_1.useFlatConfig)(host)) {
                (0, eslint_file_1.addOverrideToLintConfig)(host, options.projectRoot, {
                    files: ['**/*.vue'],
                    languageOptions: {
                        parserOptions: { parser: '@typescript-eslint/parser' },
                    },
                } // languageOptions is not in eslintrc format but for flat config
                );
            }
            (0, eslint_file_1.addIgnoresToLintConfig)(host, options.projectRoot, [
                '.nuxt/**',
                '.output/**',
                'node_modules',
            ]);
        }
        const installTask = (0, devkit_1.addDependenciesToPackageJson)(host, {}, {
            '@nuxt/eslint-config': versions_1.nuxtEslintConfigVersion,
        });
        tasks.push(installTask);
    }
    return (0, devkit_1.runTasksInSerial)(...tasks);
}
function editEslintConfigFiles(tree, projectRoot) {
    const hasVueFiles = (o) => o.files &&
        (Array.isArray(o.files)
            ? o.files.some((f) => f.endsWith('*.vue'))
            : o.files.endsWith('*.vue'));
    const addVueFiles = (o) => {
        if (!o.files) {
            o.files = ['*.vue'];
        }
        else if (Array.isArray(o.files)) {
            o.files.push('*.vue');
        }
        else {
            o.files = [o.files, '*.vue'];
        }
    };
    if ((0, eslint_file_1.lintConfigHasOverride)(tree, projectRoot, (o) => o.parserOptions && !hasVueFiles(o), true)) {
        (0, eslint_file_1.updateOverrideInLintConfig)(tree, projectRoot, (o) => !!o.parserOptions, (o) => {
            addVueFiles(o);
            return o;
        });
    }
    else {
        (0, eslint_file_1.replaceOverridesInLintConfig)(tree, projectRoot, [
            {
                files: ['*.ts', '*.tsx', '*.js', '*.jsx', '*.vue'],
                rules: {},
            },
        ]);
    }
    if ((0, eslint_file_1.lintConfigHasOverride)(tree, '', (o) => o.rules?.['@nx/enforce-module-boundaries'] && !hasVueFiles(o), true)) {
        (0, eslint_file_1.updateOverrideInLintConfig)(tree, '', (o) => !!o.rules?.['@nx/enforce-module-boundaries'], (o) => {
            addVueFiles(o);
            return o;
        });
    }
}
